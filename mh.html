<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>MCMC Text Animation — Autoplay Loop (Slower, Tight)</title>
<style>
  :root{
    --bg:#ffffff; 
    --ink:#111111; 
    --accent:#2962ff; 
    --red:#ff4d4d; 
    --green:#1db954; 
    --box:#eaf2ff; 
    --boxStroke:#4a9eff;
  }
  *{box-sizing:border-box}
  html, body{height:100%}
  body{
    margin:0; padding:0; background:var(--bg); color:var(--ink);
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Courier New", monospace;
    display:flex; flex-direction:column; align-items:center; gap:0;
  }
  .canvas-wrap{position:relative; background:#ffffff; border:0; border-radius:0; padding:0; margin:0; width:100%}
  canvas{display:block; background:#ffffff; border-radius:0; margin:0}
</style>
</head>
<body>
  <div class="canvas-wrap">
    <canvas id="canvas" width="1200" height="800"></canvas>
  </div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // Fixed parameters (no UI)
  const SPLIT_INDEX = 4;        // t
  const PX = 0.42;              // p(x)
  const PXP = 0.21;             // p(x')
  const SPEED = 0.5;            // global speed multiplier (slower)

  // HiDPI scaling
  function fitCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const cssW = Math.min(1200, Math.floor(window.innerWidth));
    const cssH = Math.min(800, Math.floor(window.innerHeight));
    canvas.style.width = cssW + "px";
    canvas.style.height = cssH + "px";
    canvas.width = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  // Data
  const originalWords   = ['The','quick','brown','fox','jumps','over','the','lazy','dog.'];
  const regeneratedWords= ['The','quick','brown','fox','leaps','across','the','flowing','river.'];

  // Phases
  const PHASES = {
    TYPING:0, HIGHLIGHT_RED:1, BRANCH:2, REGENERATE:3,
    SHOW_PROBS:4, SHOW_COIN:5, FLIP_COIN:6, ACCEPT:7, DONE:8
  };

  // State
  let phase, typingIndex, regenIndex, t, rotation, accepted, lastTs, running;

  function setFont(size=18, bold=false){
    ctx.font = `${bold ? '700 ' : ''}${size}px "Courier New", ui-monospace, monospace`;
  }

  function drawText(words, x, y, highlightStart=-1, highlightColor='#ff6666'){
    setFont(18, false);
    let cx = x;
    for (let i=0;i<words.length;i++){
      ctx.fillStyle = (highlightStart !== -1 && i >= highlightStart) ? highlightColor : '#000000';
      ctx.fillText(words[i], cx, y);
      cx += ctx.measureText(words[i] + ' ').width;
    }
  }

  function drawArrow(x1,y1,x2,y2,color='#ff6666'){
    ctx.strokeStyle = color; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    const ang = Math.atan2(y2-y1,x2-x1), L = 10;
    ctx.beginPath();
    ctx.moveTo(x2,y2);
    ctx.lineTo(x2 - L*Math.cos(ang - Math.PI/6), y2 - L*Math.sin(ang - Math.PI/6));
    ctx.moveTo(x2,y2);
    ctx.lineTo(x2 - L*Math.cos(ang + Math.PI/6), y2 - L*Math.sin(ang + Math.PI/6));
    ctx.stroke();
  }

  function drawProbabilityBox(text, x, y, w, h){
    ctx.strokeStyle = '#4a9eff'; ctx.lineWidth = 1;
    ctx.fillStyle = '#eaf2ff'; ctx.fillRect(x,y,w,h);
    ctx.strokeRect(x,y,w,h);
    ctx.fillStyle = '#000000'; setFont(18,true);
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(text, x + w/2, y + h/2 + 1);
    ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
  }

  function drawCoin(x, y, r, rot, face=null){
    ctx.save(); ctx.translate(x,y); ctx.rotate(rot);
    // edge
    ctx.fillStyle = '#d6b800'; ctx.strokeStyle = '#8f7a00'; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill(); ctx.stroke();
    // face
    ctx.fillStyle = '#6e5800'; ctx.textAlign='center'; ctx.textBaseline='middle';
    if (face === null){
      setFont(16,true); ctx.fillText("A(x, x')", 0, 0);
    } else if (face === true){
      setFont(24,true); ctx.fillText('✓',0,-2);
      setFont(12,true); ctx.fillText('ACCEPT', 0, 14);
    } else {
      setFont(24,true); ctx.fillText('✗',0,-2);
      setFont(12,true); ctx.fillText('REJECT', 0, 14);
    }
    ctx.restore();
  }

  function easeOutCubic(x){ return 1 - Math.pow(1-x,3); }

  function acceptance(){
    const A = Math.min(1, Math.max(1e-6, PXP) / Math.max(1e-6, PX));
    return A;
  }

  function resetForLoop(){
    phase = PHASES.TYPING;
    typingIndex = 0;
    regenIndex = 0;
    t = 0;
    rotation = 0;
    accepted = null;
    lastTs = 0;
    running = true;
  }

  // Core animation
  function frame(ts){
    const s = SPEED;
    if (!lastTs) lastTs = ts;
    const dt = Math.min(64, ts - lastTs) * (s/16.6667); // normalize to ~60fps
    lastTs = ts;
    if (running) t += dt;

    ctx.clearRect(0,0,canvas.width,canvas.height);

    switch(phase){
      case PHASES.TYPING:{
        if (t >= 6 && typingIndex < originalWords.length){
          typingIndex++;
          t = 0;
        }
        ctx.fillStyle = '#9aa0a6'; setFont(18,true);
        ctx.fillText('Original (x):', 40, 180);
        drawText(originalWords.slice(0, typingIndex), 120, 210);
        if (typingIndex >= originalWords.length){
          t = 0; phase = PHASES.HIGHLIGHT_RED;
        }
      } break;

      case PHASES.HIGHLIGHT_RED:{
        ctx.fillStyle = '#9aa0a6'; setFont(18,true);
        ctx.fillText('Original (x):', 40, 180);
        drawText(originalWords, 120, 210, SPLIT_INDEX, '#cc0000');
        if (t > 24){ t = 0; phase = PHASES.BRANCH; }
      } break;

      case PHASES.BRANCH:{
        ctx.fillStyle = '#9aa0a6'; setFont(18,true);
        ctx.fillText('Original (x):', 40, 180);
        ctx.fillText("Regenerated (x'):", 40, 300);
        drawText(originalWords, 120, 210, SPLIT_INDEX, '#cc0000');
        drawText(originalWords.slice(0, SPLIT_INDEX), 120, 330);
        if (t > 24){ t = 0; regenIndex = SPLIT_INDEX; phase = PHASES.REGENERATE; }
      } break;

      case PHASES.REGENERATE:{
        ctx.fillStyle = '#9aa0a6'; setFont(18,true);
        ctx.fillText('Original (x):', 40, 180);
        ctx.fillText("Regenerated (x'):", 40, 300);
        drawText(originalWords, 120, 210, SPLIT_INDEX, '#cc0000');

        let words = originalWords.slice(0, SPLIT_INDEX);
        if (regenIndex > SPLIT_INDEX) words = words.concat(regeneratedWords.slice(SPLIT_INDEX, regenIndex));
        drawText(words, 120, 330, SPLIT_INDEX, '#00aa00');

        if (t >= 6 && regenIndex < regeneratedWords.length){
          regenIndex++; t = 0;
        }
        if (regenIndex >= regeneratedWords.length && t > 18){
          t = 0; phase = PHASES.SHOW_PROBS;
        }
      } break;

      case PHASES.SHOW_PROBS: {
        ctx.fillStyle = '#9aa0a6'; setFont(18,true);
        ctx.fillText('Original (x):', 40, 180);
        ctx.fillText("Regenerated (x'):", 40, 300);

        drawText(originalWords, 120, 210, SPLIT_INDEX, '#cc0000');
        drawText(regeneratedWords, 120, 330, SPLIT_INDEX, '#00aa00');

        drawProbabilityBox('p(x)', 820, 170, 90, 70);
        drawProbabilityBox("p(x')", 820, 290, 90, 70);

        drawArrow(670, 205, 800, 205, '#cc0000');  // from x line
        drawArrow(670, 325, 800, 325, '#00aa00');  // from x' line

        if (t > 18) { t = 0; phase = PHASES.SHOW_COIN; }
      } break;

      case PHASES.SHOW_COIN: {
        ctx.fillStyle = '#9aa0a6'; setFont(18,true);
        ctx.fillText('Original (x):', 40, 180);
        ctx.fillText("Regenerated (x'):", 40, 300);

        drawText(originalWords, 120, 210, SPLIT_INDEX, '#cc0000');
        drawText(regeneratedWords, 120, 330, SPLIT_INDEX, '#00aa00');

        drawProbabilityBox('p(x)', 820, 170, 90, 70);
        drawProbabilityBox("p(x')", 820, 290, 90, 70);
        drawArrow(670, 205, 800, 205, '#cc0000');
        drawArrow(670, 325, 800, 325, '#00aa00');

        drawCoin(1030, 440, 48, 0, null);
        drawArrow(912, 205, 1000, 400, '#7aa2ff'); // p(x) to coin
        drawArrow(912, 325, 1000, 400, '#7aa2ff'); // p(x') to coin

        if (t > 18) { t = 0; phase = PHASES.FLIP_COIN; rotation = 0; accepted = null; }
      } break;

      case PHASES.FLIP_COIN:{
        ctx.fillStyle = '#9aa0a6'; setFont(18,true);
        ctx.fillText('Original (x):', 40, 180);
        ctx.fillText("Regenerated (x'):", 40, 300);

        drawText(originalWords, 120, 210, SPLIT_INDEX, '#cc0000');
        drawText(regeneratedWords, 120, 330, SPLIT_INDEX, '#00aa00');
        drawProbabilityBox('p(x)', 820, 170, 90, 70);
        drawProbabilityBox("p(x')", 820, 290, 90, 70);
        drawArrow(670, 205, 800, 205, '#cc0000');
        drawArrow(670, 325, 800, 325, '#00aa00');
        drawArrow(912, 205, 1000, 400, '#7aa2ff');
        drawArrow(912, 325, 1000, 400, '#7aa2ff');

        const A = acceptance();
        const spinProgress = Math.min(1, t/48);
        rotation = easeOutCubic(spinProgress) * Math.PI * 6; // 3 turns

        if (accepted === null && spinProgress >= 0.85){
          accepted = (Math.random() < A);
        }
        drawCoin(1030, 440, 48, rotation, accepted===null?null:accepted);

        if (spinProgress >= 1){ t = 0; phase = PHASES.ACCEPT; }
      } break;

      case PHASES.ACCEPT:{
        const ok = (accepted === true);
        ctx.fillStyle = '#9aa0a6'; setFont(18,true);
        ctx.globalAlpha = ok ? 0.20 : 1;
        ctx.fillText('Original (x):', 40, 180);
        ctx.globalAlpha = ok ? 1 : 0.20;
        ctx.fillText("Regenerated (x'):", 40, 300);

        ctx.globalAlpha = ok ? 0.20 : 1;
        drawText(originalWords, 120, 210, SPLIT_INDEX, '#cc0000');

        ctx.globalAlpha = ok ? 1 : 0.20;
        drawText(regeneratedWords, 120, 330, SPLIT_INDEX, '#00aa00');

        ctx.globalAlpha = 1;
        drawCoin(1030, 440, 48, 0, ok);

        if (t > 60){ phase = PHASES.DONE; t = 0; }
      } break;

      case PHASES.DONE:{
        // Short hold, then loop (no extra rendering to avoid visual "bottom padding")
        if (t > 10){ resetForLoop(); }
      } break;
    }

    if (running) requestAnimationFrame(frame);
  }

  // Kick off
  function startLoop(){
    resetForLoop();
    requestAnimationFrame(frame);
  }

  startLoop();
})();
</script>
</body>
</html>
