<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>MCMC Text Animation (Ultra High Resolution)</title>
<style>
  :root {
    --bg: #ffffff;
    --ink: #111111;
    --accent: #2962ff;
    --red: #ff4d4d;
    --green: #1db954;
    --box: #eaf2ff;
    --boxStroke: #4a9eff;
  }
  
  /* Universal box model reset and font setting */
  * { 
    box-sizing: border-box; 
    margin: 0;
    padding: 0;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Courier New", monospace;
  }

  /* Make the document fill the iframe and center its content */
  html, body {
    width: 100%;
    height: 100%;
    overflow: hidden; /* Prevent scrollbars */
    background: transparent;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  
  /* Container for the canvas, sets the max width */
  .canvas-wrap {
    width: 100%;
    max-width: 900px;
  }
  
  /* Canvas scales responsively while maintaining its aspect ratio */
  canvas {
    display: block;
    width: 100%;
    height: auto;
    background: #ffffff;
    border-radius: 8px; /* Optional: adds rounded corners */
  }
</style>
</head>
<body>
  <div class="canvas-wrap">
    <canvas id="canvas" width="1800" height="1200"></canvas>
  </div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // --- START: HIGH-RESOLUTION ENHANCEMENT ---
  // Get the device's pixel ratio (e.g., 2 for Retina screens).
  const dpr = window.devicePixelRatio || 1;
  
  // Store the original size specified in the HTML.
  const baseWidth = canvas.width;
  const baseHeight = canvas.height;
  
  // Increase the canvas's actual pixel count to match the screen's density.
  canvas.width = baseWidth * dpr;
  canvas.height = baseHeight * dpr;
  
  // Scale the drawing context so you can use original coordinates (1800x1200).
  ctx.scale(dpr, dpr);
  // --- END: HIGH-RESOLUTION ENHANCEMENT ---

  // Fixed parameters
  const SPLIT_INDEX = 4;
  const PX = 0.42;
  const PXP = 0.21;
  const SPEED = 0.5;

  // Data
  const originalWords = ['The','quick','brown','fox','jumps','over','the','lazy','dog.'];
  const regeneratedWords = ['The','quick','brown','fox','leaps','across','the','flowing','river.'];

  // Phases
  const PHASES = { TYPING:0, HIGHLIGHT_RED:1, BRANCH:2, REGENERATE:3, SHOW_PROBS:4, SHOW_COIN:5, FLIP_COIN:6, ACCEPT:7, DONE:8 };

  // State
  let phase, typingIndex, regenIndex, t, rotation, accepted, lastTs, running;

  function setFont(size=36, bold=false){
    ctx.font = `${bold ? '700 ' : ''}${size}px ui-monospace, SFMono-Regular, Menlo, Consolas, "Courier New", monospace`;
  }
  
  // The rest of the JavaScript animation logic remains exactly the same.
  function drawText(words, x, y, highlightStart=-1, highlightColor='#ff6666'){
    setFont(32, false);
    let cx = x;
    for (let i=0;i<words.length;i++){
      ctx.fillStyle = (highlightStart !== -1 && i >= highlightStart) ? highlightColor : '#000000';
      ctx.fillText(words[i], cx, y);
      cx += ctx.measureText(words[i] + ' ').width;
    }
  }

  function drawArrow(x1,y1,x2,y2,color='#ff6666'){
    ctx.strokeStyle = color; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    const ang = Math.atan2(y2-y1,x2-x1), L = 20;
    ctx.beginPath();
    ctx.moveTo(x2,y2);
    ctx.lineTo(x2 - L*Math.cos(ang - Math.PI/6), y2 - L*Math.sin(ang - Math.PI/6));
    ctx.moveTo(x2,y2);
    ctx.lineTo(x2 - L*Math.cos(ang + Math.PI/6), y2 - L*Math.sin(ang + Math.PI/6));
    ctx.stroke();
  }

  function drawProbabilityBox(text, x, y, w, h){
    ctx.strokeStyle = '#4a9eff'; ctx.lineWidth = 2;
    ctx.fillStyle = '#eaf2ff'; ctx.fillRect(x,y,w,h);
    ctx.strokeRect(x,y,w,h);
    ctx.fillStyle = '#000000'; setFont(32,true);
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(text, x + w/2, y + h/2 + 2);
    ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
  }

  function drawCoin(x, y, r, rot, face=null){
    ctx.save(); ctx.translate(x,y); ctx.rotate(rot);
    ctx.fillStyle = '#d6b800'; ctx.strokeStyle = '#8f7a00'; ctx.lineWidth = 6;
    ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#6e5800'; ctx.textAlign='center'; ctx.textBaseline='middle';
    if (face === null){
      setFont(28,true); ctx.fillText("A(x, x')", 0, 0);
    } else if (face === true){
      setFont(44,true); ctx.fillText('✓',0,-4);
      setFont(22,true); ctx.fillText('ACCEPT', 0, 28);
    } else {
      setFont(44,true); ctx.fillText('✗',0,-4);
      setFont(22,true); ctx.fillText('REJECT', 0, 28);
    }
    ctx.restore();
  }

  function easeOutCubic(x){ return 1 - Math.pow(1-x,3); }

  function acceptance(){
    return Math.min(1, Math.max(1e-6, PXP) / Math.max(1e-6, PX));
  }

  function resetForLoop(){
    phase = PHASES.TYPING;
    typingIndex = 0;
    regenIndex = 0;
    t = 0;
    rotation = 0;
    accepted = null;
    lastTs = 0;
    running = true;
  }

  function frame(ts){
    const s = SPEED;
    if (!lastTs) lastTs = ts;
    const dt = Math.min(64, ts - lastTs) * (s/16.6667);
    lastTs = ts;
    if (running) t += dt;

    // Use the original base dimensions to clear the entire scaled canvas.
    ctx.clearRect(0,0,baseWidth,baseHeight); 

    switch(phase){
      case PHASES.TYPING:{
        if (t >= 6 && typingIndex < originalWords.length){
          typingIndex++; t = 0;
        }
        ctx.fillStyle = '#9aa0a6'; setFont(32,true);
        ctx.fillText('Original (x):', 60, 270);
        drawText(originalWords.slice(0, typingIndex), 60, 316);
        if (typingIndex >= originalWords.length){
          t = 0; phase = PHASES.HIGHLIGHT_RED;
        }
      } break;
      case PHASES.HIGHLIGHT_RED:{
        ctx.fillStyle = '#9aa0a6'; setFont(32,true);
        ctx.fillText('Original (x):', 60, 270);
        drawText(originalWords, 60, 316, SPLIT_INDEX, '#cc0000');
        if (t > 24){ t = 0; phase = PHASES.BRANCH; }
      } break;
      case PHASES.BRANCH:{
        ctx.fillStyle = '#9aa0a6'; setFont(32,true);
        ctx.fillText('Original (x):', 60, 270);
        ctx.fillText("Regenerated (x'):", 60, 450);
        drawText(originalWords, 60, 316, SPLIT_INDEX, '#cc0000');
        drawText(originalWords.slice(0, SPLIT_INDEX), 60, 496);
        if (t > 24){ t = 0; regenIndex = SPLIT_INDEX; phase = PHASES.REGENERATE; }
      } break;
      case PHASES.REGENERATE:{
        ctx.fillStyle = '#9aa0a6'; setFont(32,true);
        ctx.fillText('Original (x):', 60, 270);
        ctx.fillText("Regenerated (x'):", 60, 450);
        drawText(originalWords, 60, 316, SPLIT_INDEX, '#cc0000');
        let words = originalWords.slice(0, SPLIT_INDEX);
        if (regenIndex > SPLIT_INDEX) words = words.concat(regeneratedWords.slice(SPLIT_INDEX, regenIndex));
        drawText(words, 60, 496, SPLIT_INDEX, '#00aa00');
        if (t >= 6 && regenIndex < regeneratedWords.length){
          regenIndex++; t = 0;
        }
        if (regenIndex >= regeneratedWords.length && t > 18){
          t = 0; phase = PHASES.SHOW_PROBS;
        }
      } break;
      case PHASES.SHOW_PROBS: {
        ctx.fillStyle = '#9aa0a6'; setFont(32,true);
        ctx.fillText('Original (x):', 60, 270);
        ctx.fillText("Regenerated (x'):", 60, 450);
        drawText(originalWords, 60, 316, SPLIT_INDEX, '#cc0000');
        drawText(regeneratedWords, 60, 496, SPLIT_INDEX, '#00aa00');
        drawProbabilityBox('p(x)', 1230, 256, 160, 120);
        drawProbabilityBox("p(x')", 1230, 436, 160, 120);
        drawArrow(1050, 308, 1200, 308, '#cc0000');
        drawArrow(1050, 488, 1200, 488, '#00aa00');
        if (t > 18) { t = 0; phase = PHASES.SHOW_COIN; }
      } break;
      case PHASES.SHOW_COIN: {
        ctx.fillStyle = '#9aa0a6'; setFont(32,true);
        ctx.fillText('Original (x):', 60, 270);
        ctx.fillText("Regenerated (x'):", 60, 450);
        drawText(originalWords, 60, 316, SPLIT_INDEX, '#cc0000');
        drawText(regeneratedWords, 60, 496, SPLIT_INDEX, '#00aa00');
        drawProbabilityBox('p(x)', 1230, 256, 160, 120);
        drawProbabilityBox("p(x')", 1230, 436, 160, 120);
        drawArrow(1050, 308, 1200, 308, '#cc0000');
        drawArrow(1050, 488, 1200, 488, '#00aa00');
        drawCoin(1500, 680, 80, 0, null);
        drawArrow(1390, 308, 1500, 600, '#7aa2ff');
        drawArrow(1390, 488, 1500, 600, '#7aa2ff');
        if (t > 18) { t = 0; phase = PHASES.FLIP_COIN; rotation = 0; accepted = null; }
      } break;
      case PHASES.FLIP_COIN:{
        ctx.fillStyle = '#9aa0a6'; setFont(32,true);
        ctx.fillText('Original (x):', 60, 270);
        ctx.fillText("Regenerated (x'):", 60, 450);
        drawText(originalWords, 60, 316, SPLIT_INDEX, '#cc0000');
        drawText(regeneratedWords, 60, 496, SPLIT_INDEX, '#00aa00');
        drawProbabilityBox('p(x)', 1230, 256, 160, 120);
        drawProbabilityBox("p(x')", 1230, 436, 160, 120);
        drawArrow(1050, 308, 1200, 308, '#cc0000');
        drawArrow(1050, 488, 1200, 488, '#00aa00');
        drawArrow(1390, 308, 1500, 600, '#7aa2ff');
        drawArrow(1390, 488, 1500, 600, '#7aa2ff');
        const A = acceptance();
        const spinProgress = Math.min(1, t/48);
        rotation = easeOutCubic(spinProgress) * Math.PI * 6;
        if (accepted === null && spinProgress >= 0.85){
          accepted = (Math.random() < A);
        }
        drawCoin(1500, 680, 80, rotation, accepted===null?null:accepted);
        if (spinProgress >= 1){ t = 0; phase = PHASES.ACCEPT; }
      } break;
      case PHASES.ACCEPT:{
        const ok = (accepted === true);
        ctx.fillStyle = '#9aa0a6'; setFont(32,true);
        ctx.globalAlpha = ok ? 0.20 : 1;
        ctx.fillText('Original (x):', 60, 270);
        ctx.globalAlpha = ok ? 1 : 0.20;
        ctx.fillText("Regenerated (x'):", 60, 450);
        ctx.globalAlpha = ok ? 0.20 : 1;
        drawText(originalWords, 60, 316, SPLIT_INDEX, '#cc0000');
        ctx.globalAlpha = ok ? 1 : 0.20;
        drawText(regeneratedWords, 60, 496, SPLIT_INDEX, '#00aa00');
        ctx.globalAlpha = 1;
        drawCoin(1500, 680, 80, 0, ok);
        if (t > 60){ phase = PHASES.DONE; t = 0; }
      } break;
      case PHASES.DONE:{
        if (t > 10){ resetForLoop(); }
      } break;
    }
    if (running) requestAnimationFrame(frame);
  }

  function startLoop(){
    resetForLoop();
    requestAnimationFrame(frame);
  }

  startLoop();
})();
</script>
</body>
</html>
